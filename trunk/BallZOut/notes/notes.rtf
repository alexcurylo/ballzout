{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf320
{\fonttbl\f0\fnil\fcharset0 Monaco;\f1\fnil\fcharset0 Cambria;\f2\fnil\fcharset0 Calibri;
\f3\fnil\fcharset0 Consolas;\f4\froman\fcharset0 Times-Roman;\f5\fnil\fcharset0 LucidaGrande;
}
{\colortbl;\red255\green255\blue255;\red9\green86\blue188;\red239\green239\blue239;}
\deftab720
\pard\pardeftab720\ql\qnatural

\f0\fs20 \cf0 //\
// Project notes\
//\
\
"Linear damping" is apparently how to implement friction.\
\
http://stackoverflow.com/questions/2569374/friction-in-box2d\
\
\pard\pardeftab720\sl340\ql\qnatural

\f1\b\fs30 \cf2 Damping\
\pard\pardeftab720\sl340\sa260\ql\qnatural

\f2\b0 \cf0 Damping is used to reduce the world velocity of bodies. Damping is different than friction because friction only occurs with contact. Damping is not a replacement for friction and the two effects should be used together.\
Damping parameters should be between 0 and infinity, with 0 meaning no damping, and infinity meaning full damping. Normally you will use a damping value between 0 and 0.1. I generally do not use linear damping because it makes bodies look floaty.\
\pard\pardeftab720\sa320\ql\qnatural

\f3\fs26 \cf0 \cb3 bodyDef.linearDamping = 0.0f;\
bodyDef.angularDamping = 0.01f;\
\pard\pardeftab720\sl340\sa260\ql\qnatural

\f2\fs30 \cf0 \cb1 Damping is approximated for stability and performance. At small damping values the damping effect is mostly independent of the time step. At larger damping values, the damping effect will vary with the time step. This is not an issue if you use a fixed time step (recommended).
\f0\fs20 \
\pard\pardeftab720\ql\qnatural
\cf0 \
\
http://www.jonvoth.com/blog/how-to-set-friction-on-circles-in-box2d/\
\
\
http://forums.tigsource.com/index.php?topic=10726.0;wap2\
"
\f4\fs32 I want move a Box2D body in a circular pattern. It's a pretty trivial thing to do.
\f5 \uc0\u8232 \u8232 
\f4 This works perfectly with SetXForm :
\f5 \uc0\u8232 \u8232 
\f4 Code:
\f5 \uc0\u8232 \u8232 
\f4 //orbitAngle loops from 0 to 360
\f5 \uc0\u8232 
\f4 float dX = cos( orbitAngle * PI / 180.0 ) ;
\f5 \uc0\u8232 
\f4 float dY = sin( orbitAngle * PI / 180.0 ) ;
\f5 \uc0\u8232 \u8232 
\f4 b2Vec2 moveVec = b2Vec2( body->GetPosition().x + dX / scale, body->GetPosition().y + dY / scale);
\f5 \uc0\u8232 
\f4 body->SetXForm( moveVec , body->GetAngle() );
\f5 \uc0\u8232 \u8232 \u8232 
\f4 The problem is SetXForm doesn't work very well with the outside forces applied to the body.
\f5 \uc0\u8232 \u8232 
\f4 I know I have to use impulses, however this doesn't produce what I want :
\f5 \uc0\u8232 \u8232 
\f4 Code:
\f5 \uc0\u8232 \u8232 
\f4 float dX = cos( orbitAngle * PI / 180.0 ) ;
\f5 \uc0\u8232 
\f4 float dY = sin( orbitAngle * PI / 180.0 ) ;
\f5 \uc0\u8232 \u8232 
\f4 b2Vec2 impulseVec = b2Vec2( 0.2 * dX , 0.2 * dY );
\f5 \uc0\u8232 
\f4 body->ApplyImpulse( impulseVec , body->GetWorldCenter() );
\f5 \uc0\u8232 \u8232 \u8232 
\f4 The body makes half circles and never returns to origin.
\f5 \uc0\u8232 \u8232 
\f4 What is the obvious thing I'm missing?"\
\
}